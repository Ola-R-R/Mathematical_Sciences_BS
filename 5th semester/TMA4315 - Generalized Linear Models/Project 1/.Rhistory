mod = glm(formula, family = poisson(link = "log"))
# log_likelihood = Y %*% eta - exp(eta)
deviance = 2*(logLik(mod_sat) - logLik(mod))
return(list(coef,deviance,vcov))
}
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
data <- rpois(N, lambda = 5)
set.seed(1000)
myglm <-  function(formula,data,start = 0) {
X = model.matrix(formula,data)
Y = data[,1]
n = dim(X)[1]
p = dim(X)[2]
beta_0 = rep(1,p)
beta = solve(t(X) %*%X) %*% t(X) %*% Y #Least Squares Estimate
epsilon = 0.01
#Run Fisher Iterations
while (norm(beta-beta_0,type = "2")/norm(beta_0, type = "2") > epsilon) {
beta_0 = beta
eta = X %*% beta
lambda = exp(eta)
A = diag(lambda[,1])
F = t(X) %*% A %*% X #Fisher information matrix
s = t(X) %*% (Y - lambda) #Score function
beta = beta + solve(F) %*% s
}
vcov = solve(F)
coef = matrix(,nrow=2,ncol=2)
coef[,1] = beta
coef[,2] = sqrt(diag(vcov)) #Standard errors of the coefficients
#Calculate Deviance
mod_sat = glm(Y ~ as.factor(1:length(y)), family = poisson(link = "log"))
mod = glm(formula, family = poisson(link = "log"))
# log_likelihood = Y %*% eta - exp(eta)
deviance = 2*(logLik(mod_sat) - logLik(mod))
return(list(coef,deviance,vcov))
}
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
N <- 20
data <- rpois(N, lambda = 5)
y = data[,1]
set.seed(1000)
myglm <-  function(formula,data,start = 0) {
X = model.matrix(formula,data)
Y = data[,1]
n = dim(X)[1]
p = dim(X)[2]
beta_0 = rep(1,p)
beta = solve(t(X) %*%X) %*% t(X) %*% Y #Least Squares Estimate
epsilon = 0.01
#Run Fisher Iterations
while (norm(beta-beta_0,type = "2")/norm(beta_0, type = "2") > epsilon) {
beta_0 = beta
eta = X %*% beta
lambda = exp(eta)
A = diag(lambda[,1])
F = t(X) %*% A %*% X #Fisher information matrix
s = t(X) %*% (Y - lambda) #Score function
beta = beta + solve(F) %*% s
}
vcov = solve(F)
coef = matrix(,nrow=2,ncol=2)
coef[,1] = beta
coef[,2] = sqrt(diag(vcov)) #Standard errors of the coefficients
#Calculate Deviance
mod_sat = glm(Y ~ as.factor(1:length(y)), family = poisson(link = "log"))
mod = glm(formula, family = poisson(link = "log"))
# log_likelihood = Y %*% eta - exp(eta)
deviance = 2*(logLik(mod_sat) - logLik(mod))
return(list(coef,deviance,vcov))
}
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
N <- 20
y <- rpois(N, lambda = 5)
# y = data[,1]
t = data[,2]
set.seed(1000)
myglm <-  function(formula,data,start = 0) {
X = model.matrix(formula,data)
Y = data[,1]
n = dim(X)[1]
p = dim(X)[2]
beta_0 = rep(1,p)
beta = solve(t(X) %*%X) %*% t(X) %*% Y #Least Squares Estimate
epsilon = 0.01
#Run Fisher Iterations
while (norm(beta-beta_0,type = "2")/norm(beta_0, type = "2") > epsilon) {
beta_0 = beta
eta = X %*% beta
lambda = exp(eta)
A = diag(lambda[,1])
F = t(X) %*% A %*% X #Fisher information matrix
s = t(X) %*% (Y - lambda) #Score function
beta = beta + solve(F) %*% s
}
vcov = solve(F)
coef = matrix(,nrow=2,ncol=2)
coef[,1] = beta
coef[,2] = sqrt(diag(vcov)) #Standard errors of the coefficients
#Calculate Deviance
mod_sat = glm(Y ~ as.factor(1:length(y)), family = poisson(link = "log"))
mod = glm(formula, family = poisson(link = "log"))
# log_likelihood = Y %*% eta - exp(eta)
deviance = 2*(logLik(mod_sat) - logLik(mod))
return(list(coef,deviance,vcov))
}
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
N <- 20
y <- rpois(N, lambda = 5)
# y = data[,1]
# t = data[,2]
myglm(y ~ t, data)
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
y <- rpois(N, lambda = 5)
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
y <- rpois(20, lambda = 5)
Ã¦y = data[,1]
t = data[,2]
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
y <- rpois(20, lambda = 5)
set.seed(1000)
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
y <- rpois(20, lambda = 5)
# load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
y <- rpois(20, lambda = 5)
load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata"))
View(data)
View(data)
testData <- data.frame(rpois(10, 10))
View(testData)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10), t)
View(testData)
View(testData)
testOur <- myglm(y ~ ., testData)
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y = data$y
X = model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (all(abs(scoreF) < 1e-04)) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
beta <- beta + solve(fisherInf) %*% scoreF
}
coefficients <- matrix(, nrow = 2, ncol = 2)
coefficients[,1] = beta
coefficients[,2] = sqrt(diag(vcov))
# Deviance:
yhat <- exp(eta)
deviance <- 2 * sum(logLik(y) - logLik(yhat))
# Estimated variance matrix:
vcov <- solve(fisherInf)
return (list(coefficents, deviance, vcov))
}
testOur <- myglm(y ~ ., testData)
testOur <- myglm(formula, testData)
View(testData)
y <- testData[,1]
testOur <- myglm(y ~ , testData)
testOur <- myglm(y ~ ., testData)
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y = data[,1]
X = model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (all(abs(scoreF) < 1e-04)) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
beta <- beta + solve(fisherInf) %*% scoreF
}
coefficients <- matrix(, nrow = 2, ncol = 2)
coefficients[,1] = beta
coefficients[,2] = sqrt(diag(vcov))
# Deviance:
yhat <- exp(eta)
deviance <- 2 * sum(logLik(y) - logLik(yhat))
# Estimated variance matrix:
vcov <- solve(fisherInf)
return (list(coefficents, deviance, vcov))
}
set.seed(100)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10),t)
testOur <- myglm(y ~ ., testData)
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y = data[,1]
X = model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (TRUE) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
if all(abs(scoreF) < 1e-04) {
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y = data[,1]
X = model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (TRUE) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
if (all(abs(scoreF) < 1e-04)) {
break}
beta <- beta + solve(fisherInf) %*% scoreF
}
coefficients <- matrix(, nrow = 2, ncol = 2)
coefficients[,1] = beta
coefficients[,2] = sqrt(diag(vcov))
# Deviance:
yhat <- exp(eta)
deviance <- 2 * sum(logLik(y) - logLik(yhat))
# Estimated variance matrix:
vcov <- solve(fisherInf)
return (list(coefficents, deviance, vcov))
}
set.seed(100)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10),t)
testOur <- myglm(y ~ ., testData)
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y = data[,1]
X = model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (TRUE) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
if (all(abs(scoreF) < 1e-04)) {
break}
beta <- beta + solve(fisherInf) %*% scoreF
}
coefficients <- matrix(, nrow = 2, ncol = 2)
coefficients[,1] <- beta
coefficients[,2] <- sqrt(diag(vcov))
# Deviance:
yhat <- exp(eta)
deviance <- 2 * sum(logLik(y) - logLik(yhat))
# Estimated variance matrix:
vcov <- solve(fisherInf)
return (list(coefficents, deviance, vcov))
}
set.seed(100)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10),t)
testOur <- myglm(y ~ ., testData)
beta
beta
beta
summary(beta)
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y = data[,1]
X = model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (TRUE) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
if (all(abs(scoreF) < 1e-04)) {
break}
beta <- beta + solve(fisherInf) %*% scoreF
}
coefficients <- matrix(, nrow(beta), ncol = 2)
coefficients[,1] <- beta
coefficients[,2] <- sqrt(diag(vcov))
# Deviance:
yhat <- exp(eta)
deviance <- 2 * sum(logLik(y) - logLik(yhat))
# Estimated variance matrix:
vcov <- solve(fisherInf)
return (list(coefficents, deviance, vcov))
}
set.seed(100)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10),t)
testOur <- myglm(y ~ ., testData)
testBuilt <- glm(y ~ ., family = poisson(link = log), data = testdata)
set.seed(100)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10),t)
testBuilt <- glm(y ~ ., family = poisson(link = log), data = testdata)
set.seed(100)
t <- c(16,15,17,18,15,14,16,17,18,15)
testData <- data.frame(rpois(10, 10),t)
testBuilt <- glm(y ~ ., family = poisson(link = log), data = testdata)
testData <- data.frame(rpois(10, 10),t)
testBuilt <- glm(y ~ ., family = poisson(link = log), data = testData)
summary(testBuilt)
vcov(testBuilt)
install.packages("boomer")
install.packages("boomer")
remotes::install_github("moodymudskipper/boomer")
remotes::install_github("moodymudskipper/boomer")
remotes::install_github("moodymudskipper/boomer")
install.packages("boomer")
install.packages("C:/Users/olara/Downloads/boomer_0.1.1.zip", repos = NULL, type = "win.binary")
library("boomer")
boom(glm(y ~ ., family = poisson(link = log), data = testdata))
library("boomer")
library("boomer")
library(boomer)
detach("package:boomer", unload = TRUE)
library(boomer)
boom(glm(y ~ ., family = poisson(link = log), data = testdata))
boom(testBuilt)
boom(1 + !1 * 2)
library("boomer")
load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata")) # Defaults to "data"
testOur <- myglm(y ~ ., data)
knitr::opts_chunk$set(echo = TRUE)
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y <- data$y
X <- model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (TRUE) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
if (all(abs(scoreF) < 1e-04)) {
break}
beta <- beta + solve(fisherInf) %*% scoreF
}
# Deviance:
eta <- as.vector((X %*% beta))
yhat <- exp(eta)
deviance <- 2 * sum(dpois(y, y, TRUE) - dpois(y, yhat, TRUE))
# Estimated variance matrix:
vcov <- solve(fisherInf)
# Coefficients
coefficients <- matrix(, nrow = 3, ncol = 2)
colnames(coefficients) <- c("Estimate", "Std. Error")
rownames(coefficients) <- c("(Intercept)", "t^2", "t")
coefficients[,1] = beta
coefficients[,2] = sqrt(diag(vcov))
return (list(coefficients = coefficients,deviance = deviance,vcov = vcov))
}
set.seed(100)
t1 <- c(16,15,17,18,15,14,16,17,18,15) # t^2
t2 <- c(16,14,19,18,15,14,16,17,18,15) # t
testData <- data.frame(y = rpois(10, 10),t1,t2)
testOur <- myglm(y ~ ., testData)
testOur
testOur <- myglm(y ~ ., testData)
testOur
testBuilt <- glm(y ~ ., family = poisson(link = log), data = testData)
summary(testBuilt)$coefficients
summary(testBuilt)$deviance
vcov(testBuilt)
load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata")) # Defaults to "data"
testOur <- myglm(y ~ I(t^2) + t, data)
testOur
# testBuilt <- glm(y ~ I(t^2) + t, family = poisson(link = log), data)
# summary(testBuilt)
# vcov(testBuilt)
b_2_t = testOur$coefficients[2,1] / (sqrt(testOur$vcov[2,2]))
# z-value from Wald-test
abs(b_2_t)
z = testOur$coefficients[2,1] / (sqrt(testOur$vcov[2,2]))
# z-value from Wald-test
abs(z)
z = testOur$coefficients[2,1] / (sqrt(testOur$vcov[2,2]))
# z-value from Wald-test
abs(z)
load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata")) # Defaults to "data"
qchisq(.95, 135-2)
qchisq(.95, 135-3)
criticalValue <- qchisq(0.95, dim(data)[1] - length(testOur$beta))
criticalValue
myglm <- function(formula, data, start = 0) {
# Defining y and X:
y <- data$y
X <- model.matrix(formula, data)
# Defining beta:
beta_0 = rep(start, ncol(X))
beta = solve(t(X) %*% X) %*% t(X) %*% y
# Fisher scoring algorithm:
while (TRUE) {
beta_0 = beta
eta <- as.vector((X %*% beta))
scoreF <- t(X) %*% (y - exp(eta))
A <- diag(exp(eta))
fisherInf <- t(X) %*% A %*% X
if (all(abs(scoreF) < 1e-04)) {
break}
beta <- beta + solve(fisherInf) %*% scoreF
}
# Deviance:
eta <- as.vector((X %*% beta))
yhat <- exp(eta)
deviance <- 2 * sum(dpois(y, y, TRUE) - dpois(y, yhat, TRUE))
# Estimated variance matrix:
vcov <- solve(fisherInf)
# Coefficients
coefficients <- matrix(, nrow = 3, ncol = 2)
colnames(coefficients) <- c("Estimate", "Std. Error")
rownames(coefficients) <- c("(Intercept)", "t^2", "t")
coefficients[,1] = beta
coefficients[,2] = sqrt(diag(vcov))
return (list(coefficients = coefficients,deviance = deviance,vcov = vcov))
}
load(url("https://www.math.ntnu.no/emner/TMA4315/2022h/hoge-veluwe.Rdata")) # Defaults to "data"
testOur <- myglm(y ~ I(t^2) + t, data)
testOur
# Just to check if it works on this data aswell
# testBuilt <- glm(y ~ I(t^2) + t, family = poisson(link = log), data)
# summary(testBuilt)
# vcov(testBuilt)
criticalValue <- qchisq(0.95, dim(data)[1] - length(testOur$beta))
criticalValue
length(testOur$beta)
criticalValue <- qchisq(0.95, dim(data)[1] - length(testOur$coefficients))
criticalValue
length(testOur$beta)
length(testOur$coefficients)
criticalValue <- qchisq(0.95, dim(data)[1] - length(testOur$coefficients[1]))
criticalValue
length(testOur$coefficients)
length(testOur$coefficients[1])
length(testOur$coefficients[,1])
criticalValue <- qchisq(0.95, dim(data)[1] - length(testOur$coefficients[,1]))
criticalValue
library(boot, lib.loc = "C:/Program Files/R/R-4.2.1/library")
omegaHat = sqrt(1/(2*testOur$coefficients[1,2]))
thetaHat = omega^2 * testOur$coefficients[1,3]
omegaHat = sqrt(1/(2*testOur$coefficients[1,2]))
thetaHat = omegaHat^2 * testOur$coefficients[1,3]
omegaHat = sqrt(1/(2*testOur$coefficients[1,2]))
thetaHat = omegaHat^2 * testOur$coefficients[1,2]
cat("omega hat:", omegaHat, "theta hat:", thetaHat)
omegaHat = sqrt(1/(2*testOur$coefficients[1,2]))
thetaHat = omegaHat^2 * testOur$coefficients[1,-1]
cat("omega hat:", omegaHat, "theta hat:", thetaHat)
testOur$coefficients[1,2]
testOur$coefficients[0,1]
testOur$coefficients[,1]
omegaHat = sqrt(1/(2*testOur$coefficients[,1][2]))
thetaHat = omegaHat^2 * testOur$coefficients[,1][3]
cat("omega hat:", omegaHat, "theta hat:", thetaHat)
testOur$coefficients[,1][2]
testOur$coefficients[,1]
testOur$coefficients[1,1]
testOur$coefficients[2,1]
omegaHat = sqrt(1/(2*testOur$coefficients[2,1]))
thetaHat = omegaHat^2 * testOur$coefficients[3,1]
cat("omega hat:", omegaHat, "theta hat:", thetaHat)
testOur$coefficients[2,1]
testOur$coefficients[3,1]
omegaHat = sqrt(1/(2*testOur$coefficients[2,1]))
omegaHat = sqrt(1/(2*testOur$coefficients[2,1]))
thetaHat = omegaHat^2 * testOur$coefficients[3,1]
cat("omega hat:", omegaHat, "theta hat:", thetaHat)
omegaHat = sqrt(1/(2*testOur$coefficients[2,1]))
2*testOur$coefficients[2,1]
omegaHat = sqrt(abs(1/(2*testOur$coefficients[2,1])))
thetaHat = omegaHat^2 * testOur$coefficients[3,1]
cat("omega hat:", omegaHat, "theta hat:", thetaHat)
omegaHat_var <- (-1/(2 * sqrt(abs(2 * testOur$coefficients[2,1]^3))))^2 * testOur$vcov[2,2]
omegaHat_se <- sqrt(omegaHat_var)
thataHat_var <- (1/(2 * testOur$coefficients[2,1]))^2 * testOur$vcov[3,3] + (testOur$coefficients[3,1]/(2 * testOur$coefficients[2,1]^2))
thetaHat_se <- sqrt(thetaHat_var)
thetaHat_var <- (1/(2 * testOur$coefficients[2,1]))^2 * testOur$vcov[3,3] + (testOur$coefficients[3,1]/(2 * testOur$coefficients[2,1]^2))
thetaHat_se <- sqrt(thetaHat_var)
View(testOur)
testOur[["vcov"]]
testOur$vcov[3,3]
testOur$vcov[-1,-1]
testOur$vcov[2,2]
testOur$vcov[3,3]
thetaHat_var <- (1/(2 * testOur$coefficients[2,1]))^2 * testOur$vcov[3,3] + (testOur$coefficients[3,1]/(2 * testOur$coefficients[2,1]^2))
thetaHat_se <- sqrt(thetaHat_var)
