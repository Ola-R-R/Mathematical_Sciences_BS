sigma2 <- results$sigma2
acceptRate = results$acceptrate
effectiveSize(as.mcmc(taus))
effectiveSize(as.mcmc(tausBLOCK))
effectiveSize(as.mcmc(taus))
effectiveSize(as.mcmc(taus[,1]))
effectiveSize(as.mcmc(taus[,201]))
effectiveSize(as.mcmc(taus[,366]))
effectiveSize(as.mcmc(tausBLOCK[,1]))
effectiveSize(as.mcmc(tausBLOCK[,201]))
effectiveSize(as.mcmc(tausBLOCK[,366]))
effectiveSize(as.mcmc(taus[,1]))
effectiveSize(as.mcmc(taus[,201]))
effectiveSize(as.mcmc(taus[,366]))
effectiveSize(as.mcmc(tausBLOCK[,1]))
effectiveSize(as.mcmc(tausBLOCK[,201]))
effectiveSize(as.mcmc(tausBLOCK[,366]))
par(mfrow = c(3,1))
acf(expit(tausBLOCK[,1]))
acf(expit(tausBLOCK[,201]))
acf(expit(tausBLOCK[,366]))
par(mfrow = c(3,1))
acf(expit(tausBLOCK[,1]))
acf(expit(tausBLOCK[,201]))
acf(expit(tausBLOCK[,366]))
par(mfrow = c(3,1))
acf(expit(tausBLOCK[,1]))
acf(expit(tausBLOCK[,201]))
acf(expit(tausBLOCK[,366]))
effectiveSize(as.mcmc(resultsBLOCK))
effectiveSize(as.mcmc(resultsBLOCK[1:2]))
resultsBLOCK[1:2]
?effectiveSize
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE, tidy = TRUE, fig.align = "center", tidy.opts = list(width.cutoff = 60))
library("tidyverse")
library("ggfortify")
library("MASS")
library("knitr")
library("rmarkdown")
library("palmerpenguins")
library("GGally")
library("amen")
#install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
# update.packages("INLA", dep = TRUE)
library("INLA")
library("float")
library("invgamma")
library("mrbsizeR")
library("locfit")
library("coda")
library("likelihoodExplore")
# Loading the rainfall data
load(file="rain.rda")
# Plotting response as a function of time
plot(n.rain ~ day, rain, type = "l", lwd = 2, xlab = "t (day)", ylab = "Amount of rain exceeding 1mm")
# Adding February 29th
points(60,0, col = "blue", pch = 19)
# Acceptance probability from Eq. 1.9
acceptProb <- function(y,tau,tauProp,n) {
firstTerm <- y * (log(1 + exp(-tau)) - log(1 + exp(-tauProp)))
secondTerm <- (n - y) * ((tau - tauProp) + (log(1 + exp(-tau)) - log(1 + exp(-tauProp))))
return(min(1,exp(sum(firstTerm + secondTerm))))
}
# MCMC algorithm
MC <- function(rain, tau. = 1, M = 50000, seed = 98, burnin = 1000, printEvery = 100, verbose = F) {
set.seed(seed)
TT <- 366
tauMat <- matrix(0, nrow = M + 1, ncol = TT)
tauMat[1,] <- tau.
sigma2Vec <- numeric(M)
tau <- tauMat[1,]
accepts <- matrix(F, nrow = M, ncol = TT)
QQ <- tridiag(append(append(1,rep(2,TT-2)),1), rep(-1,TT-1), rep(-1,TT-1))
startTime <- proc.time()[3]
for (i in 1:M) {
if(((i %% printEvery) == 0) && verbose) {
# print current state and expected computation time left:
currState <- paste(i, collapse=", ")
print(paste0("current state for iteration ", i, "/", M, ": ", currState))
currTime <- proc.time()[3]
timeTaken <- currTime - startTime
fracDone <- (i-1)/M
fracLeft <- 1 - fracDone
timeLeftEst <- (timeTaken / fracDone) * fracLeft
print(paste0("estimated time left: ", round(timeLeftEst), " seconds"))
}
# Drawing sigma2 from Eq. 1.6
sigma2 <- rinvgamma(1, shape = (2 + (TT - 1)/2), rate = (.05 + .5 * sum(diff(tau)^2)))
# Defining precision matrix
Q <- QQ/sigma2
A <- 1
B <- -1
QAA <- Q[A,A]
QAB <- Q[A,B]
# Defining mean from Eq. 1.7
muAcondB <- -QAA^(-1) * QAB[1] * tau[B][1]
# Defining Precision from Eq. 1.8
QAcondB <- QAA
# Drawing new tau from normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(QAcondB^(-1)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tau[A],tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- T
}
for (j in 2:(TT-1)) {
A <- j
B <- -j
QAA <- Q[A,A]
QAB <- Q[A,B]
# Defining mean from Eq. 1.7
muAcondB <- -(QAA^(-1) * QAB[(j-1):j]) %*% tau[B][(j-1):j]
# Defining Precision from Eq. 1.8
QAcondB <- QAA
# Drawing new tau from normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(QAcondB^(-1)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tau[A],tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- T
}
}
A <- TT
B <- -TT
QAA <- Q[A,A]
QAB <- Q[A,B]
# Defining mean from Eq. 1.7
muAcondB <- -QAA^(-1) * QAB[TT-1] * tau[B][TT-1]
# Defining Precision from Eq. 1.8
QAcondB <- QAA
# Drawing new tau from normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(QAcondB^(-1)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tau[A],tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- T
}
tauMat[i+1,] <- tau
sigma2Vec[i] <- sigma2
}
acceptRate <- mean(accepts)
currTime <- proc.time()[3]
print(paste0("Total time taken: ", round((currTime - startTime)/60, digits=2), " minutes"))
print(paste0("Acceptance rate: ", round(acceptRate, digits=4)))
return(list("taumatrix" = tauMat[(burnin+1):(M+1),], "sigma2" = sigma2Vec[(burnin+1):M], "acceptrate" = acceptRate))
}
results <- MC(rain,M=5000)
taus = results$taumatrix
sigma2 <- results$sigma2
acceptRate = results$acceptrate
means <- c()
for (i in 1:366) {means[i] <- mean(expit(taus[,i]))}
MCBLOCK <- function(rain, tau. = 1, M = 50000, N, seed = 98, burnin = 1000, printEvery = 100, verbose = F) {
set.seed(seed)
TT <- 366
tauMat <- matrix(0, nrow = M + 1, ncol = TT)
tauMat[1,] <- tau.
sigma2Vec <- numeric(M)
tau <- tauMat[1,]
accepts <- matrix(F, nrow = M, ncol = TT)
QQ <- tridiag(append(append(1,rep(2,TT-2)),1), rep(-1,TT-1), rep(-1,TT-1))
stepp <- seq(1,TT,N)
startTime <- proc.time()[3]
for (i in 1:M) {
if(((i %% printEvery) == 0) && verbose) {
# print current state and expected computation time left:
currState <- paste(i, collapse=", ")
print(paste0("current state for iteration ", i, "/", M, ": ", currState))
currTime <- proc.time()[3]
timeTaken <- currTime - startTime
fracDone <- (i-1)/M
fracLeft <- 1 - fracDone
timeLeftEst <- (timeTaken / fracDone) * fracLeft
print(paste0("estimated time left: ", round(timeLeftEst), " seconds"))
}
sigma2 <- rinvgamma(1, shape = (2 + (TT - 1)/2), rate = (.05 + .5 * sum(diff(tau)^2)))
Q <- QQ/sigma2
QAAa1 <- Q[1:N,1:N]
QABa1 <- Q[1:N,-(1:N)]
Qa1 <- solve(QAAa1) %*% QABa1[,1]
QAAmid <- Q[2:(N+1),2:(N+1)]
QABmid <- Q[2:(N+1),-(2:(N+1))]
Qmid <- solve(QAAmid) %*% QABmid[,1:2]
# a = 1
tauI <- tau[1:N]
muAcondB <- -Qa1 * tau[N+1]
QAcondB <- QAAa1
tauProp <- t(chol(solve(QAcondB))) %*% rnorm(N) + muAcondB
if (runif(1) < acceptProb(rain$n.rain[1:N],tauI,tauProp,rain$n.year[1:N])) {
tau[1:N] <- tauProp
accepts[1,1:N] <- TRUE
}
if (length(stepp) > 2) {
# mid
for (j in stepp[2:(ceiling(TT/N-1))]) {
A = j:(j+N-1)
B = -A
tauI <- tau[A]
tauminusI <- tau[B]
muAcondB <- -Qmid %*% tauminusI[(j-1):(j)]
QAcondB <- QAAmid
tauProp <- t(chol(solve(QAcondB))) %*% rnorm(N) + muAcondB
if (runif(1) < acceptProb(rain$n.rain[A],tauI,tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- TRUE
}
}
}
# b = TT
A = tail(stepp,1):TT
B = -A
QAAb366 <- Q[A,A]
QABb366 <- Q[A,B]
if (length(A) != 1) {
Qb366 <- solve(QAAb366) %*% QABb366[,tail(stepp,1)-1]
tauI <- tau[A]
tauminusI <- tau[B]
muAcondB <- -Qb366[,ncol(Qb366)] * tauminusI[length(tauminusI)]
QAcondB <- QAAb366
tauProp <- t(chol(solve(QAcondB))) %*% rnorm(length(A)) + muAcondB
if (runif(1) < acceptProb(rain$n.rain[A],tauI,tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- TRUE
}
} else {
Qb366 <- solve(QAAb366) %*% QABb366[tail(stepp,1)-1]
tauI <- tau[A]
tauminusI <- tau[B]
muAcondB <- -Qb366[,ncol(Qb366)] * tauminusI[length(tauminusI)]
QAcondB <- QAAb366
tauProp <- rnorm(1, muAcondB, sqrt(solve(QAcondB)))
if (runif(1) < acceptProb(rain$n.rain[A],tauI,tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- TRUE
}
}
tauMat[i+1,] <- tau
sigma2Vec[i] <- sigma2
}
acceptRate <- mean(accepts)
currTime <- proc.time()[3]
print(paste0("Total time taken: ", round((currTime - startTime)/60, digits=2), " minutes"))
print(paste0("Acceptance rate: ", round(acceptRate, digits=4)))
return(list("taumatrix" = tauMat[(burnin+1):(M+1),], "sigma2" = sigma2Vec[(burnin+1):M], "acceptrate" = acceptRate))
}
resultsBLOCK <- MCBLOCK(rain,M=5000,N=10)
tausBLOCK <- resultsBLOCK$taumatrix
sigma2BLOCK <- resultsBLOCK$sigma2
acceptRateBLOCK = resultsBLOCK$acceptrate
nsamples <- 5000
effectiveSize(as.mcmc(resultsBLOCK))
meansBLOCK <- c()
for (i in 1:366) {meansBLOCK[i] <- mean(expit(tausBLOCK[,i]))}
startTime <- proc.time()[3]
mod <- inla(n.rain ~ -1 + f(day, model="rw1", constr=F, hyper = list(prec = list(prior = "loggamma", param = c(2, .05)))),
family = "binomial",
data = rain,
Ntrials = n.years,
control.compute = list(config = T),
verbose = F,
control.inla = list(strategy="simplified.laplace", int.strategy="ccd"),
control.fixed = list(prec.intercept = 1, prec = 1))
currTime <- proc.time()[3]
print(paste0("Total time taken: ", round((currTime - startTime)/60, digits=2), " minutes"))
mod$summary.fitted.values[1,1]
mod$summary.fitted.values[201,1]
mod$summary.fitted.values[366,1]
# par(mfrow = c(3,1))
plot(means, type = "l", lwd = 5, ylim = c(0,1), col = "red")
lines(meansBLOCK, type = "l", lwd = 3, col = "blue")
lines(mod$summary.fitted.values[,1], type = "l")
legend("topright", inset = .05, legend = c("MCMC", "MCMCBLOCK", "INLA"), lty = 1, col = c("red", "blue", "black"), cex=0.6)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE, tidy = TRUE, fig.align = "center", tidy.opts = list(width.cutoff = 60))
library("tidyverse")
library("ggfortify")
library("MASS")
library("knitr")
library("rmarkdown")
library("palmerpenguins")
library("GGally")
library("amen")
#install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
# update.packages("INLA", dep = TRUE)
library("INLA")
library("float")
library("invgamma")
library("mrbsizeR")
library("locfit")
library("coda")
library("likelihoodExplore")
library("boot")
library("kableExtra")
library("RColorBrewer")
# Loading the rainfall data
load(file="rain.rda")
# Plotting response as a function of time
plot(n.rain ~ day, rain, type = "l", lwd = 2, xlab = "t (day)", ylab = "Amount of rain exceeding 1mm")
# Adding February 29th
points(60,0, col = "blue", pch = 19)
# Acceptance probability from Eq. 1.9
acceptProb <- function(y,tau,tauProp,n) {
firstTerm <- y * (log(1 + exp(-tau)) - log(1 + exp(-tauProp)))
secondTerm <- (n - y) * ((tau - tauProp) + (log(1 + exp(-tau)) - log(1 + exp(-tauProp))))
return(min(1,exp(sum(firstTerm + secondTerm))))
}
# MCMC algorithm
MC <- function(rain, tau. = 1, M = 50000, seed = 98, burnin = 1000, printEvery = 100, verbose = F) {
set.seed(seed)
TT <- 366
tauMat <- matrix(0, nrow = M + 1, ncol = TT)
tauMat[1,] <- tau.
sigma2Vec <- numeric(M)
tau <- tauMat[1,]
accepts <- matrix(F, nrow = M, ncol = TT)
QQ <- tridiag(c(1,rep(2,TT-2),1), rep(-1,TT-1), rep(-1,TT-1))
startTime <- proc.time()[3]
for (i in 1:M) {
if(((i %% printEvery) == 0) && verbose) {
# print current state and expected computation time left:
currState <- paste(i, collapse=", ")
print(paste0("current state for iteration ", i, "/", M, ": ", currState))
currTime <- proc.time()[3]
timeTaken <- currTime - startTime
fracDone <- (i-1)/M
fracLeft <- 1 - fracDone
timeLeftEst <- (timeTaken / fracDone) * fracLeft
print(paste0("estimated time left: ", round(timeLeftEst), " seconds"))
}
# Drawing sigma2 from Eq. 1.6
sigma2 <- rinvgamma(1, shape = (2 + (TT - 1)/2), rate = (.05 + .5 * sum(diff(tau)^2)))
# Defining precision matrix
Q <- QQ/sigma2
A <- 1
B <- -1
QAA <- Q[A,A]
QAB <- Q[A,B]
# Defining mean from Eq. 1.7
muAcondB <- -QAA^(-1) * QAB[1] * tau[B][1]
# Defining Precision from Eq. 1.8
QAcondB <- QAA
# Drawing new tau from normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(QAcondB^(-1)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tau[A],tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- T
}
for (j in 2:(TT-1)) {
A <- j
B <- -j
QAA <- Q[A,A]
QAB <- Q[A,B]
# Defining mean from Eq. 1.7
muAcondB <- -(QAA^(-1) * QAB[(j-1):j]) %*% tau[B][(j-1):j]
# Defining Precision from Eq. 1.8
QAcondB <- QAA
# Drawing new tau from normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(QAcondB^(-1)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tau[A],tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- T
}
}
A <- TT
B <- -TT
QAA <- Q[A,A]
QAB <- Q[A,B]
# Defining mean from Eq. 1.7
muAcondB <- -QAA^(-1) * QAB[TT-1] * tau[B][TT-1]
# Defining Precision from Eq. 1.8
QAcondB <- QAA
# Drawing new tau from normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(QAcondB^(-1)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tau[A],tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- T
}
tauMat[i+1,] <- tau
sigma2Vec[i] <- sigma2
}
acceptRate <- mean(accepts)
currTime <- proc.time()[3]
print(paste0("Total time taken: ", round((currTime - startTime)/60, digits=2), " minutes"))
print(paste0("Acceptance rate: ", round(acceptRate, digits=4)))
return(list("taumatrix" = tauMat[(burnin+1):(M+1),], "sigma2" = sigma2Vec[(burnin+1):M], "acceptrate" = acceptRate))
}
results <- MC(rain)
taus = results$taumatrix
sigma2 <- results$sigma2
acceptRate = results$acceptrate
MCBLOCK <- function(rain, N, tau. = 1, M = 50000, seed = 98, burnin = 1000, printEvery = 100, verbose = F) {
set.seed(seed)
TT <- 366
tauMat <- matrix(0, nrow = M + 1, ncol = TT)
tauMat[1,] <- tau.
sigma2Vec <- numeric(M)
tau <- tauMat[1,]
accepts <- matrix(F, nrow = M, ncol = TT)
QQ <- tridiag(c(1,rep(2,TT-2),1), rep(-1,TT-1), rep(-1,TT-1))
stepp <- seq(1,TT,N)
startTime <- proc.time()[3]
for (i in 1:M) {
if(((i %% printEvery) == 0) && verbose) {
# print current state and expected computation time left:
currState <- paste(i, collapse=", ")
print(paste0("current state for iteration ", i, "/", M, ": ", currState))
currTime <- proc.time()[3]
timeTaken <- currTime - startTime
fracDone <- (i-1)/M
fracLeft <- 1 - fracDone
timeLeftEst <- (timeTaken / fracDone) * fracLeft
print(paste0("estimated time left: ", round(timeLeftEst), " seconds"))
}
# Drawing sigma2 from Eq. 1.6
sigma2 <- rinvgamma(1, shape = (2 + (TT - 1)/2), rate = (.05 + .5 * sum(diff(tau)^2)))
# Defining precision matrix
Q <- QQ/sigma2
# Precomputing alle the precision matrices we need
QAAa1 <- Q[1:N,1:N]
QABa1 <- Q[1:N,-(1:N)]
Qa1 <- solve(QAAa1) %*% QABa1[,1]
QAAmid <- Q[2:(N+1),2:(N+1)]
QABmid <- Q[2:(N+1),-(2:(N+1))]
Qmid <- solve(QAAmid) %*% QABmid[,1:2]
# a = 1
tauI <- tau[1:N]
# Defining mean from Eq. 1.7
muAcondB <- -Qa1 * tau[N+1]
# Defining Precision from Eq. 1.8
QAcondB <- QAAa1
# Drawing new taus from multivariate normal distribution
tauProp <- t(chol(solve(QAcondB))) %*% rnorm(N) + muAcondB
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[1:N],tauI,tauProp,rain$n.year[1:N])) {
tau[1:N] <- tauProp
accepts[1,1:N] <- TRUE
}
if (length(stepp) > 2) {
# a > 1 and b < 366
for (j in stepp[2:(ceiling(TT/N-1))]) {
A = j:(j+N-1)
B = -A
tauI <- tau[A]
tauminusI <- tau[B]
# Defining mean from Eq. 1.7
muAcondB <- -Qmid %*% tauminusI[(j-1):(j)]
# Defining Precision from Eq. 1.8
QAcondB <- QAAmid
# Drawing new taus from multivariate normal distribution
tauProp <- t(chol(solve(QAcondB))) %*% rnorm(N) + muAcondB
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tauI,tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- TRUE
}
}
}
# b = TT
A = tail(stepp,1):TT
B = -A
QAAb366 <- Q[A,A]
QABb366 <- Q[A,B]
if (length(A) != 1) {
Qb366 <- solve(QAAb366) %*% QABb366[,tail(stepp,1)-1]
tauI <- tau[A]
tauminusI <- tau[B]
# Defining mean from Eq. 1.7
muAcondB <- -Qb366[,ncol(Qb366)] * tauminusI[length(tauminusI)]
# Defining Precision from Eq. 1.8
QAcondB <- QAAb366
# Drawing new taus from multivariate normal distribution
tauProp <- t(chol(solve(QAcondB))) %*% rnorm(length(A)) + muAcondB
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tauI,tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- TRUE
}
} else {
Qb366 <- solve(QAAb366) %*% QABb366[tail(stepp,1)-1]
tauI <- tau[A]
tauminusI <- tau[B]
# Defining mean from Eq. 1.7
muAcondB <- -Qb366[,ncol(Qb366)] * tauminusI[length(tauminusI)]
# Defining Precision from Eq. 1.8
QAcondB <- QAAb366
# Drawing new taus from multivariate normal distribution
tauProp <- rnorm(1, muAcondB, sqrt(solve(QAcondB)))
# Accept/reject step
if (runif(1) < acceptProb(rain$n.rain[A],tauI,tauProp,rain$n.year[A])) {
tau[A] <- tauProp
accepts[i,A] <- TRUE
}
}
tauMat[i+1,] <- tau
sigma2Vec[i] <- sigma2
}
acceptRate <- mean(accepts)
currTime <- proc.time()[3]
print(paste0("Total time taken: ", round((currTime - startTime)/60, digits=2), " minutes"))
print(paste0("Acceptance rate: ", round(acceptRate, digits=4)))
return(list("taumatrix" = tauMat[(burnin+1):(M+1),], "sigma2" = sigma2Vec[(burnin+1):M], "acceptrate" = acceptRate))
}
resultsBLOCK <- MCBLOCK(rain,15)
tausBLOCK <- resultsBLOCK$taumatrix
sigma2BLOCK <- resultsBLOCK$sigma2
acceptRateBLOCK = resultsBLOCK$acceptrate
cat("Effective sample size of single site update: ",max(effectiveSize(as.mcmc(cbind(taus,sigma2)))),"\nEffective sample size of block site update : ",max(effectiveSize(as.mcmc(cbind(tausBLOCK,sigma2BLOCK)))))
resultsBLOCK <- MCBLOCK(rain,15)
resultsBLOCK <- MCBLOCK(rain,15)
results <- MC(rain)
