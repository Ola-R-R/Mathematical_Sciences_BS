knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE, tidy = TRUE, fig.align = "center", tidy.opts = list(width.cutoff = 60))
library("tidyverse")
library("ggfortify")
library("MASS")
library("knitr")
library("rmarkdown")
library("palmerpenguins")
library("GGally")
library("amen")
#install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
# update.packages("INLA", dep = TRUE)
library("INLA")
library("float")
library("invgamma")
# Loading the rainfall data
load(file="rain.rda")
# Plotting response as a function of time
plot(n.rain ~ day, rain, type = "l", lwd = 2, xlab = "t (day)", ylab = "Amount of rain exceeding 1mm")
# Adding February 29th
points(60,0, col = "blue", pch = 19)
numeric(10)
# Chunk 1: setup
library(knitr)
knitr::opts_chunk$set(
echo = T, tidy=T, message=F, warning=F,
strip.white=F,
prompt=F,
cache=T,
root.dir = "./Exe2bsm",
size="scriptsize",
fig.width=7,
fig.height=5,
fig.align = "center"
)
# Chunk 2: imports
library(ggplot2)
library(MASS)
library(Matrix)
library(SoDA)
install.packages("SoDA")
library(ggplot2)
library(MASS)
library(Matrix)
library(SoDA)
load("./rain.rda")
load("./rain.rda")
link = function(tau){
# Expit link
return(exp(tau)/(1+exp(tau)))
}
logbin = function(n, y, tau){
# Remake and use this
return(y*log(1+exp(-tau)) - (n-y)*log(1+exp(tau)))
}
logAccRatio = function(n, y, tauProp, tau) {
return(y*(tauProp - tau) + n* log((1+exp(tau))/(1+exp(tauProp))))
}
mhFirst = function(tau, sigma, yt, t, norm_it, unif){
# Function to take the first MH step, i.e., for t=1
mu_ab = tau[2]
prop_tau = norm_it*sigma + mu_ab
n = 39
# ratio = acceptRatio(n, yt, prop_tau, tau[t])
ratio = logAccRatio(39, yt, prop_tau, tau[t])
# if (runif(1) < min(c(1,ratio))){
if (unif < min(c(1,ratio))){
return(list(tau=prop_tau, accepted=1))
}
else{return(list(tau=tau[t], accepted=0))}
}
mhLast = function(tau, sigma, yt, t, norm_it, unif){
# Function to take the last MH step, i.e., for t=366
mu_ab = tau[365]
prop_tau = norm_it*sigma + mu_ab
# ratio = acceptRatio(n, yt, prop_tau, tau[t])
ratio = logAccRatio(39, yt, prop_tau, tau[t])
if (unif < min(c(1,ratio))){
return(list(tau=prop_tau, accepted=1))
}
else{return(list(tau=tau[t], accepted=0))}
}
mcmcIndivid = function(N, dt, sigma0=0.05){
# Allocate memory
Ttot = 366
tau = matrix(NA, nrow=N, ncol = Ttot)
sigma = numeric(length = N)
tau_i = numeric(length = Ttot)
normMat = matrix(rep(rnorm(Ttot), N), nrow = N, ncol=Ttot)
# unifMat = matrix(rep(runif(Ttot), N), nrow=N, ncol=Ttot)
unifMat = matrix(rep(log(runif(Ttot)), N), nrow=N, ncol=Ttot) # log uniform
# Find init vals
tau[1,] = rnorm(Ttot) # init tau drawn from normal distr.
sigma[1] = sigma0
# Run mcmc for N iterations
accepted = 0
for (i in 2:N){
tau_i = tau[i-1,]
sigma_i = sqrt(sigma[i-1])
# Take first MH step for t=1
mhStep = mhFirst(tau_i, sigma_i, n.rain[1], 1, normMat[i,1], unifMat[i,1])
tau_i[1] = mhStep$tau
accepted = accepted + mhStep$accepted
# Perform MH steps for 1<t<366
for (t in 2:(Ttot-1)){
mu_ab    = 1/2 * (tau_i[t-1] + tau_i[t+1])
prop_tau = normMat[i,t]*sigma_i/2 + mu_ab
ratio    = logAccRatio(n.years[t], n.rain[t], prop_tau, tau_i[t])
if (unifMat[i,t] < min(c(1,ratio))){
tau_i[t] = prop_tau
accepted = accepted + 1
}
# else{tau[i,t] = tau_i[t]}
}
# Take last MH step for t=366
mhStep = mhLast(tau_i, sigma_i, dt$n.rain[366], 1, normMat[i,366], unifMat[i,366])
tau_i[366] = mhStep$tau
tau[i,] = tau_i
accepted = accepted + mhStep$accepted
# Squared diff. of tau vec.
# tQt = sum((tau[i,-Ttot] - tau[i,-1])^2) # this sim tau vals.
tQt = sum(diff(tau[i,])^2) # this sim tau vals.
# Gibbs step (Draw from IG)
sigma[i] = 1/rgamma(1, shape=2 + (Ttot-1)/2, scale=0.05 + 0.5*tQt) # Gibbs inline
setTxtProgressBar(pb,i)
}
close(pb)
return(list(tau=tau, sigma=sigma, accProb = accepted/(N*Ttot)))
}
a          = 0
Q          = triDiag(diagonal = 2, upper = -1, lower = -1, nrow = 366)
library(profvis)
Q          = triDiag(diagonal = 2, upper = -1, lower = -1, nrow = 366)
triDiag
install.packages("mrbsizeR")
Q[366,366] = 1
library(mrbsizeR)
Q          = triDiag(diagonal = 2, upper = -1, lower = -1, nrow = 366)
Q          = tridiag(diagonal = 2, upper = -1, lower = -1, nrow = 366)
Q          = tridiag(mainDiag = 2, upperDiag = -1, lowerDiag = -1, nrow = 366)
tridiag
log
min
list
numeric
matrix
rnorm
